<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Hacker | HarveyNick]]></title>
  <link href="http://www.harveynick.com/blog/categories/hacker/atom.xml" rel="self"/>
  <link href="http://www.harveynick.com/"/>
  <updated>2012-01-05T01:02:01+00:00</updated>
  <id>http://www.harveynick.com/</id>
  <author>
    <name><![CDATA[Nick Johnson]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Language Post Mortem and Some Other Notes]]></title>
    <link href="http://www.harveynick.com/blog/2010/10/16/language-post-mortem-and-some-other-notes/"/>
    <updated>2010-10-16T11:53:40+01:00</updated>
    <id>http://www.harveynick.com/blog/2010/10/16/language-post-mortem-and-some-other-notes</id>
    <content type="html"><![CDATA[<p>A couple nuggets of knowledge came out of my "You're Speaking My Language, Baby" series of posts, so I though I'd just take a quick moment to talk about them.</p>

<p>The first two are perhaps the most obvious by far. Firstly: if you actually write blog posts, people are more likely to read your blog. Funny that, huh? While my post on installing <a href="http://harveynick.com/blog/2008/08/24/mdl-celtx-on-the-acer-aspire-one/">Celtx on the Acer Aspire one</a> is still my most popular by some margin (probably because it actually provides some utility), I actually had my highest numbers of hits per day during the last week. Secondly: I get less hits over the weekend. Lax working habits for the win!</p>

<!-- more -->


<p>What's also interesting is the relative popularity of the individual parts of the series. Most popular first, it goes like this:</p>

<ol>
<li>Introduction</li>
<li>C++</li>
<li>Conclusion</li>
<li>Java</li>
<li>Objective-C</li>
</ol>


<p><span class='pullquote-right' data-pullquote='when it comes to specifics, C++ gets the most interest'>
Now, my number of hits still isn't exactly stellar, so this is a fairly small sample size, but it's still quite interesting. People seem to be far more interested in reading about C++ than any of the other languages. In general, readers tend to want to know what it is I'm actually talking about, and what conclusion I come to, but when it comes to specifics, C++ gets the most interest. Is this a recommendation of the language, or the oposite, though? People could be reading what I say about it because they think it's the sensible option... or because the folly of the language makes them seethe with rage. Hard to say. Perhaps I'll look for some metrics of programming language popularity online.<br/>
</span></p>

<p>In one of those curious events the internet throws up, the writer of a blog I read on a regular basis also just started to work on a project of a potentially similar nature, and started off with some musings on which programming language to use. I'm talking about Shamus Young in his <a href="http://www.shamusyoung.com/twentysidedtale/?p=9644">Twenty Sided</a> blog (I should really add it to my blog roll). Interestingly, and slightly comically, he came came to an equal and oposite conclusion to my own. He didn't consider Objective-C (not out loud, anyway), but decided that Java was the language to use if he wanted to produce something with commercial viability, but C++ was the language to use if he wanted to do some prototyping.</p>

<p>I'm still scratching my head at this in some ways. I don't care how much experience you have in C++, you're still likely to program faster in almost any language other than C. But in other ways it makes perfect sense. He has about a decade's worth of experience with C++ (likewise I have about ten years worth of Java under my belt), but only limited exposure to Java. He's looking at building a complete game, so he's being influenced by games like <a href="http://www.minecraft.net/">Minecraft</a> (which I will be talking about more later) which were successfully developed by an individual (in Java, as I understand it). If you're making something a bit niche and you don't have massive amounts of resources, then having a game which can be effortlessly ported to every major operating system is a good thing. You want to expand you potential audience as much as possible. Also, if your target demographic slants towards the nerd side of the spectrum then you don't want count out Linux, nor OSX (which gets more nerd love than you might expect). Having your game be able to run out of a browser doesn't hurt, either.</p>

<p>I'm not (at this point) looking at building a complete game, but a piece of technology which could potentially be used by multiple games, though. Something of the order of a physics engine. Middleware is the term I seem to hear used. Thus Java (which I have more experience with) is my prototyping language, but C++ makes sense as an eventual target.</p>

<p>I've been holding back on what I'm actually doing, but I essentially outed myself when I said it was similar to what Shamus is. So: I'm doing something connected to procedural content generation. I'll explain more about what that means as I go along.</p>

<p>In other news I have two weeks off work. Seems I haven't used the vast majority of my holidays this year and taking the entire month of December off is not considered to be ideal. Thus: I have two weeks to do with as I please. I may visit my parents or even some of my friends down south. I'll also spend quite a bit of time sitting in coffee shops with a book and a note pad. Coffee shops are good places to think, I find. Just the right amount of bussle. I'm also going to crack on with Clockwork Aphid. I'm tinkering with some implementation details at the moment, but I plan on writing about what I have so far as well. I'm also hoping to make the Heston Blumenthal chilli con carne I mentioned in a <a href="http://harveynick.com/blog/2010/08/24/its-hestontastic/">previous post</a>, but there are complications. Firstly, he's quite specific about the types of chilli powder you should use and some only seem to be available from the good ol' USA. They're on order, so hopefully they'll arrive fairly soon. Secondly, there's clearly a mistake in the recipe, unless Heston want me to boil a pan of water and prepare a bowl of ice water for purely ornamental purposes. This isn't completely outside the bounds of reason.</p>

<p>More updates soon. Look to the skies!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[You're Speaking my Language, Baby. Part 5: Conclusion]]></title>
    <link href="http://www.harveynick.com/blog/2010/10/13/youre-speaking-my-language-baby-part-5-conclusion/"/>
    <updated>2010-10-13T13:00:04+01:00</updated>
    <id>http://www.harveynick.com/blog/2010/10/13/youre-speaking-my-language-baby-part-5-conclusion</id>
    <content type="html"><![CDATA[<p>So... what's the conclusion? It mostly comes back to the fact that I'm doing this mainly for fun (though you may have trouble believing it). That being the case I'm going to start working in Java. In fact I already have started working in Java, and I've already written the first bits of code. I'll talk about and make them available soon.</p>

<!-- more -->


<p><span class='pullquote-right' data-pullquote='Games are among the more demanding things most people do with their computers'>
I just can't ignore the sheer applicability of C++, though, much as I may dislike it as a language. Most game developers are going to have the majority of their legacy code written in C++ and that creates a lot of momentum.Games are among the more demanding things most people do with their computers, so they generally try to squeeze every last drop of performance out of the system they're running on. C++ does have the potential to provide a performance advantage over Java (even if you might end up loosing that to your AI system when you starting having to use Lua to script behaviours). Another one of the reasons for this project was to create a bit of work which might act sort of like a portfolio piece. So, once the project has reached an early, but functional, stage of development I'm going to re-implement it in C++ and then see how I feel about the two different implementations before continuing. It's not impossible that I'll end up keeping both, but more than likely I'll kill one and just stick with the other.<br/>
</span></p>

<p>By a process of elimination you might have realised that I'm now counting Objective-C out. This is true, but I have another side project I may end up using it on. One which lends itself quite well to being either an iPhone/iPad app or a website. Or all three. Objective-C is clearly quite applicable to the first two, and surprisingly applicable to the last, if you go the Objective-C -> MacRuby -> Ruby on Rails route.</p>

<p>That was the plan, at least, until I went ahead and did something silly. I have more than a passing interest in programming language design and so found myself reading about other programming languages. Stupidly, I found a couple which have enough merit that I really can't count them out.</p>

<p>The first of these is <a href="http://www.digitalmars.com/d/">D</a>, which is designed to fix a lot of the problems with C++ whilst maintaining its advantages. It seems to succeed at this quite well, so far as I can tell. It also seems to have direct access to a lot of things built directly for C/C++.</p>

<p>Then we have <a href="http://www.scala-lang.org/">Scala</a> and <a href="http://fantom.org/">Fantom</a>, which use the Java virtual machine as their runtime. Both seem capable of achieving the same level of performance as Java itself, but take away some of the legacy cruft which Java has been unable to shake, whilst adding extra useful features. Scala I'm only just starting to learn about, but people seem to like it a lot. Fantom, I think, might be perilously close to being the perfect programming language by many metrics, though. Don't take my word for it, have a read about it. I dare you not to be impressed (assuming, of course, that you are the sort of person who gets impressed with these sort of things). It adds some very cool extensions and has direct support for some very useful things, such as allowing both dynamic and static typing under the developer's control.</p>

<p>Both Scala and Fantom can transparently use libraries written in Java, though Fantom can also deploy to both .net and javascript (for web development).</p>

<p>All three of the these languages are interesting enough for me for to not count them out entirely, so I might also try a port to one or more of them.</p>

<p>As always, comments are welcome, so please feel free to try and convince me of the error of my ways. Keep it civil, though, I know how excited programming language discussions seem to make some people.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[You're Speaking my Language, Baby. Part 4: Objective-C]]></title>
    <link href="http://www.harveynick.com/blog/2010/10/12/youre-speaking-my-language-baby-part-4-objective-c/"/>
    <updated>2010-10-12T12:00:01+01:00</updated>
    <id>http://www.harveynick.com/blog/2010/10/12/youre-speaking-my-language-baby-part-4-objective-c</id>
    <content type="html"><![CDATA[<p>The last language I'm considering is <strong>Objective-C</strong>. I know this language the least of three. To make matters worse, while Java and C++ share a similar syntax, Objective-C is completely different in places. That being said, it's semantically very similar to Java (more so than C++) and people who know it well speak very highly of it. i.e. it does not appear to be anywhere near as broken as C++. The language itself has some dynamic capability built in, but also has all of the additional dynamic options available to C++ (more on that later) and an excellent Ruby implementation which sits directly on top of the Objective-C runtime (<a href="http://www.macruby.org/">MacRuby</a>).</p>

<!-- more -->


<p>In general, Objective-C should be faster than Java, but not as fast as C++. It doesn't use a virtual machine, but it does have a minimal run time which is used to implement the more dynamic message passing paradigm it uses in place of standard message calls between objects. It also has optional garbage collection, allowing you to make a choice between stability and performance when you need to (i.e. you can get the code working and worry about the memory allocation later). It's also able to leverage all of the power of both the <a href="http://llvm.org/">LLVM</a> back end and the newer <a href="http://clang.llvm.org/">Clang</a> front end, which C++ currently can't.</p>

<p>While there aren't a lot of directly relevant tools available for Objective-C itself, it is able to directly use any code or library written in either C or C++. No problems there, then.</p>

<p>It's the last metric which is the kick in the teeth fot Objective-C, though. In short: no one really uses it unless they're programming for an Apple platform. As a result, unless you're programming specifically for either OSX or iOS you'll loose out on a lot of frameworks. Objective-C is a first class language in the Gnu Compiler Collection (GCC), so it can be deployed easily enough under Linux (minus a lot of the good frameworks). This is not the case under windows, however, where there doesn't seem to be any good deployment options. I have no problem ignoring Windows, but directly precluding it would appear to be somewhat foolhardy when building a piece of technology related to computer games. It wouldn't be too much of a problem if I was only doing this as an academic exercise, but I actually have delusions of people using it.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[You're Speaking my Language, Baby. Part 3: C++]]></title>
    <link href="http://www.harveynick.com/blog/2010/10/11/youre-speaking-my-language-baby-part-3-c/"/>
    <updated>2010-10-11T12:00:48+01:00</updated>
    <id>http://www.harveynick.com/blog/2010/10/11/youre-speaking-my-language-baby-part-3-c</id>
    <content type="html"><![CDATA[<p>The second language I'm considering is <strong>C++</strong>. This is the language that I use the most at my day job. It's also the language that's used to build the vast majority of computer games and one hell of a lot of commercial software. I'm not as familiar with it as I am with Java, but I know it well enough to be productive with it. I'm also familiar enough with it to know how horribly <a href="http://yosefk.com/c++fqa/">broken</a> it is in many respects. One of the major design goals of Java (among other more modern programming languages) was to fix the problems with C++. It also has no dynamic capabilities what-so-ever, but it's possible to paper over this by using a minimal dynamic runtime such as <a href="http://www.lua.org/">Lua</a> for scripting.</p>

<!-- more -->


<p>All things being equal, C++ is the fastest of the three languages. It is also the one you're most likely to write bad code in, though, so there's a bit of a trade off here.</p>

<p>As I mentioned, most games are programmed using C++. As a result, there is a veritable shit load of graphics engine options. I would probably tend towards using the open source<a href="http://www.ogre3d.org/">Ogre3D</a> rendering engine (or something similar), but it's worth baring in mind that I could easily switch to using, say, the Quake 3 engine (open sourced by id) if I wanted to. I could also port the project to using a commercial graphics engine if I had the desire to do such a thing.<br/>
The measure of applicability to other parties is definitely a point in favour of C++. Code written in C++ would be the easiest of the three for deployment as part of a larger project, as that project is most likely to be written in C++. In terms of acting as a developer showcase C++ has the edge as well, as it's the language a lot of companies ask for code samples in.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[You're Speaking my Language, Baby. Part 2: Java]]></title>
    <link href="http://www.harveynick.com/blog/2010/10/10/youre-speaking-my-language-baby-part-2-java/"/>
    <updated>2010-10-10T12:00:26+01:00</updated>
    <id>http://www.harveynick.com/blog/2010/10/10/youre-speaking-my-language-baby-part-2-java</id>
    <content type="html"><![CDATA[<p>The first language I'm considering is <strong>Java</strong>. This is by far the language I'm most comfortable and proficient with. It was used for about 90% of my Bachelors degree, I wrote the entire codebase of my PhD using it, and it gets used here and there in my day job. I'm comfortable with Java, and find it to be quite a pleasant language to program in. Big tick on the question regarding my ability to use it, then. Java has some modest dynamic capabilities built in, but it also has a lot of small options for using higher level languages for the scripting, the cleanest of which is possibly Groovy.</p>

<!-- more -->


<p>Java has a bad reputation performance wise, but this largely isn't true any more. It does run using a virtual machine, but is compiled to native code at run time. It's a lot easier to write good code using Java than the other languages I'm considering, and that can help with performance a lot, but in general Java has the potential to be the slowest of the three, all things being equal.</p>

<p>Tools are actually not a problem. There are a lot of high quality graphics engines available for Java, with the <a href="http://www.jmonkeyengine.com/">Java Monkey Engine</a> (JME) being my favourite. A physics add-on is available in the form of <a href="http://code.google.com/p/jmephysics/">JMEPhysics</a>, with the next version slated to have a physics engine baked in. Raw OpenGL is also an option with <a href="http://lwjgl.org/">LWJGL</a>, should I want it. Likewise, I suspect that the <a href="http://www.reddwarfserver.org/">Red Dwarf Server</a> is likely meet my communication needs.</p>

<p>The applicability of Java to other interested parties is an interesting question. A lot of software gets written in Java. A LOT. But the vast majority of it is not games. Largely, I think this is because it's perceived to be lacking in the performance department. It's also a little harder to protect you code when you're writing in Java, too. The previously mentioned JME has the support of a commercial games company, though, so clearly there is interest. Computers are getting faster at quite a rate, so performance has the potential to be less of a concern, especially if the project you're working on has the whiff of a server side application about it. When it comes to server side code, I think Java is definitely winning the race. Frankly, I have a bit of trouble calling this one either way.</p>

<p>One language down, two to go. Look for the next post tomorrow, should you be interested in such things.</p>
]]></content>
  </entry>
  
</feed>
